datasource db {
  provider = "mysql"
  url      = env("DATABASE_URL")
}

generator client {
  provider = "prisma-client-js"
}

model User {
  id             Int       @id @default(autoincrement())
  fullname        String
  email          String    @unique
  phoneNumber    String    @unique
  passwordHash   String
  profilePicture String?
  admin        Boolean   @default(false)
  createdAt      DateTime  @default(now())
  updatedAt      DateTime  @updatedAt


  // Relations
  addresses Address[] // A user can have multiple addresses
  shops     Shop[] // A user can own multiple shops/stores
  orders    Order[] // A user can place multiple orders
}

model Product {
  id          Int      @id @default(autoincrement())
  categoryId  Int      
  name        String
  description String
  brand       String?
  image       String
  netQty      Int? 
  unit        Unit?
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  // Relations
  category  Category        @relation(fields: [categoryId], references: [id])
  inShops   ShopInventory[]
  orderItems OrderItem[]
}

model Shop {
  id           Int      @id @default(autoincrement())
  userId       Int // The user who owns the shop
  storeName    String
  description  String?
  storeBanner  String?
  city         String
  address      String
  latitude     Float
  longitude    Float
  deliveryTime Int // Estimated delivery time in minutes
  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt

  // Relations
  owner     User             @relation(fields: [userId], references: [id])
  inventory ShopInventory[]
  orders    Order[]
}


// -- CORE USER & AUTH MODELS --



model Address {
  id           Int      @id @default(autoincrement())
  userId       Int      
  addressLine1 String
  addressLine2 String?
  city         String
  state        String
  postalCode   String
  country      String
  latitude     Float? 
  longitude    Float?
  isDefault    Boolean  @default(false)

  // Relations
  user   User    @relation(fields: [userId], references: [id], onDelete: Cascade)
  orders Order[]
}

// -- SHOP, PRODUCT & INVENTORY MODELS --


// Global categories for consistent filtering
model Category {
  id          Int      @id @default(autoincrement())
  name        String
  description String?

  // Relations
  products Product[]
}

// A global catalog of products


// Manages product price and stock for each specific shop
model ShopInventory {
  id          Int      @id @default(autoincrement())
  shopId      Int
  productId   Int
  price       Float
  quantity    Int
  netQty      Float    // e.g., 500, 1.5, etc.
  unit        Unit     
  isAvailable Boolean  @default(true)

  shop    Shop    @relation(fields: [shopId], references: [id], onDelete: Cascade)
  product Product @relation(fields: [productId], references: [id], onDelete: Cascade)

  @@unique([shopId, productId])
}

// -- ORDER, DELIVERY & PAYMENT MODELS --

model Order {
  id                Int       @id @default(autoincrement())
  userId            Int
  shopId            Int
  deliveryAddressId Int
  totalAmount       Float
  orderStatus       OrderStatus @default(pending)
  paymentStatus     PaymentStatus @default(pending)
  createdAt         DateTime  @default(now())
  updatedAt         DateTime  @updatedAt

  // Relations
  user    User        @relation(fields: [userId], references: [id])
  shop    Shop        @relation(fields: [shopId], references: [id])
  address Address     @relation(fields: [deliveryAddressId], references: [id])
  items   OrderItem[]
  delivery Delivery? // An order has one delivery
  payment  Payment?  // An order has one payment
}

model OrderItem {
  id           Int   @id @default(autoincrement())
  orderId      Int
  productId    Int
  quantity     Int
  pricePerUnit Float // Price at the time of order

  // Relations
  order   Order   @relation(fields: [orderId], references: [id], onDelete: Cascade)
  product Product @relation(fields: [productId], references: [id])
}



model Delivery {
  id             Int             @id @default(autoincrement())
  orderId        Int             @unique
  agentId        Int?
  deliveryStatus DeliveryStatus  @default(pending_assignment)
  assignedAt     DateTime?
  pickedUpAt     DateTime?
  deliveredAt    DateTime?

  // Relations
  order Order         @relation(fields: [orderId], references: [id])
}

model Payment {
  id             Int      @id @default(autoincrement())
  orderId        Int      @unique
  paymentMethod  String   
  transactionId  String?
  amount         Float
  paymentStatus  PaymentStatus @default(pending)
  createdAt      DateTime @default(now())

  // Relations
  order Order @relation(fields: [orderId], references: [id])
}

// -- ENUMS --

enum OrderStatus {
  pending
  confirmed
  preparing
  out_for_delivery
  delivered
  cancelled
  failed
}

enum DeliveryStatus {
  pending_assignment
  assigned
  picked_up
  delivered
  failed
}

enum PaymentStatus {
  pending
  completed
  failed
  refunded
}

enum Unit {
  g        // gram
  kg       // kilogram
  mg       // milligram
  lb       // pound
  oz       // ounce

  ml       // millilitre
  l        // litre
  cl       // centilitre
  gal      // gallon

  pcs      // pieces (default for countable items)
  pack     // packs
  box      // boxes
  bottle   // bottles
  can      // cans
  jar      // jars
  bag      // bags

  dozen    // 12 units
  pair     // 2 units
  tray     // group of items like eggs
}
